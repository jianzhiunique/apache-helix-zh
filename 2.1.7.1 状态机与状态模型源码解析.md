StateModelDefinition.Builder

```
// TODO move this to model.builder package, refactor StateModelConfigGenerator to use this
  /**
   * 构建一个状态模型
   */
  public static class Builder {
    private final String _statemodelName;
    private String initialState;
    Map<String, Integer> statesMap;
    Map<Transition, Integer> transitionMap;
    Map<String, String> stateConstraintMap;

    /**
     * 使用名称构建状态模型
     * @param name state model name
     */
    public Builder(String name) {
      this._statemodelName = name;
      statesMap = new HashMap<>();
      transitionMap = new HashMap<>();
      stateConstraintMap = new HashMap<>();
    }

    /**
     * 副本启动时它的初始状态，一般会使用OFFLINE
     * @param initialState
     */
    public Builder initialState(String initialState) {
      this.initialState = initialState;
      return this;
    }

    /**
     * 本方法定义所有合法的状态，设置优先级是因为约束要满足
     * 如果STATE1有个约束是1，STATE2有个约束是3，但只有一个节点是启动的
     * 那么helix将使用优先级来查看STATE的约束是不是有更高的配置
     * 使用-1代表没有约束，比如OFFLINE
     Define all valid states using this method. Set the priority in which the constraints must be satisfied. Lets say STATE1 has a constraint of 1 and STATE2 has a constraint of 3 but only one node is up then Helix will uses the priority to see STATE constraint has to be given higher preference Use -1 to indicates states with no constraints, like OFFLINE
     * @param state
     * @param priority
     */
    public Builder addState(String state, int priority) {
      statesMap.put(state, priority);
      return this;
    }

    /**
     * 此方法优先级为Integer.MAX_VALUE
     * @param state
     */
    public Builder addState(String state) {
      addState(state, Integer.MAX_VALUE);
      return this;
    }

    /**
     * 使用此方法定义所有合法的state转换，优先级是来排序转换用的
     * Helix尝试最大化转换的数量，以便在不违反约束的情况下，并行地触发
     * 转换首先基于优先级进行排序，并且转换会在不违反约束的情况下以贪婪的方式进行
     * @param fromState source
     * @param toState destination
     * @param priority priority, higher value is higher priority
     * @return Builder
     */
    public Builder addTransition(String fromState, String toState, int priority) {
      transitionMap.put(new Transition(fromState, toState), priority);
      return this;
    }

    /**
     * 使用最大优先级来添加转换
     * @see #addTransition(String, String, int)
     * @param fromState
     * @param toState
     * @return Builder
     */
    public Builder addTransition(String fromState, String toState) {
      addTransition(fromState, toState, Integer.MAX_VALUE);
      return this;
    }

    /**
     * 设置某个state的最大的副本数
     * @param state state name
     * @param upperBound maximum
     * @return Builder
     */
    public Builder upperBound(String state, int upperBound) {
      stateConstraintMap.put(state, String.valueOf(upperBound));
      return this;
    }

    /**
     * 可以使用此方法创建动态的数量改变，基于不同的参数
     * 目前支持两个值
     * R --> 代表着resource创建时指定的副本数
     * 这样可以在不需要创建多个不同的状态机的情况下为不同的资源设置不同的复制因子replication factor
     * N --> 代表集群中的所有节点
     * 在resource需要存在于所有几点的场景下非常有用，这种方式下我们可以添加/删除节点，而不需要改变bounds
     * @param state
     * @param bound
     * @return Builder
     */
    public Builder dynamicUpperBound(String state, String bound) {
      stateConstraintMap.put(state, bound);
      return this;
    }

    /**
     * 从这个Builder构建状态模型定义
     * @return StateModelDefinition
     */
    public StateModelDefinition build() {
      //这里是传入的状态模型名称，稍后会看看可以传哪些值，以及他是怎么构建出来的
      ZNRecord record = new ZNRecord(_statemodelName);

      // 对state进行优先级排序
      ArrayList<String> statePriorityList = new ArrayList<String>(statesMap.keySet());
      Comparator<? super String> c1 = new Comparator<String>() {

        @Override
        public int compare(String o1, String o2) {
          return statesMap.get(o1).compareTo(statesMap.get(o2));
        }
      };
      Collections.sort(statePriorityList, c1);

      // 对转换进行优先级排序
      ArrayList<Transition> transitionList = new ArrayList<Transition>(transitionMap.keySet());
      Comparator<? super Transition> c2 = new Comparator<Transition>() {
        @Override
        public int compare(Transition o1, Transition o2) {
          return transitionMap.get(o1).compareTo(transitionMap.get(o2));
        }
      };
      Collections.sort(transitionList, c2);
      List<String> transitionPriorityList = new ArrayList<>(transitionList.size());
      for (Transition t : transitionList) {
        transitionPriorityList.add(t.toString());
      }

      //设置初始状态
      record.setSimpleField(StateModelDefinitionProperty.INITIAL_STATE.toString(), initialState);
      //设置状态优先级列表
      record.setListField(StateModelDefinitionProperty.STATE_PRIORITY_LIST.toString(),
          statePriorityList);
      //设置状态转换优先级列表
      record.setListField(StateModelDefinitionProperty.STATE_TRANSITION_PRIORITYLIST.toString(),
          transitionPriorityList);

      // 计算完整的state路径图（拓扑）
      StateTransitionTableBuilder stateTransitionTableBuilder = new StateTransitionTableBuilder();
      Map<String, Map<String, String>> transitionTable =
          stateTransitionTableBuilder.buildTransitionTable(statePriorityList,
              new ArrayList<>(transitionMap.keySet()));
      for (String state : transitionTable.keySet()) {
        record.setMapField(state + ".next", transitionTable.get(state));
      }

      // state的计数
      for (String state : statePriorityList) {
        HashMap<String, String> metadata = new HashMap<String, String>();
        if (stateConstraintMap.get(state) != null) {
          metadata.put("count", stateConstraintMap.get(state));
        } else {
          metadata.put("count", "-1");
        }
        record.setMapField(state + ".meta", metadata);
      }
      //返回StateModelDefinition
      return new StateModelDefinition(record);
    }

  }

  @Override
  public boolean equals(Object o) {
    if (o == null) {
      return false;
    }

    if (!(o instanceof StateModelDefinition)) {
      return false;
    }

    StateModelDefinition stateModelDefinition = (StateModelDefinition) o;
    return _initialState.equals(stateModelDefinition._initialState) && _statesCountMap
        .equals(stateModelDefinition._statesCountMap) && _statesPriorityList
        .equals(stateModelDefinition._statesPriorityList) && _stateTransitionPriorityList
        .equals(stateModelDefinition._stateTransitionPriorityList) &&
        _stateTransitionTable.equals(stateModelDefinition._stateTransitionTable);
  }

  /**
   * 获取state->count的map。其中排序按照它的状态优先级
   *
   * @return state count map: state->count
   */
  public LinkedHashMap<String, Integer> getStateCountMap(int candidateNodeNum, int totalReplicas) {
    LinkedHashMap<String, Integer> stateCountMap = new LinkedHashMap<>();
    List<String> statesPriorityList = getStatesPriorityList();

    int replicas = totalReplicas;
    for (String state : statesPriorityList) {
      String num = getNumInstancesPerState(state);
      if (candidateNodeNum <= 0) {
        break;
      }
      if ("N".equals(num)) {
        stateCountMap.put(state, candidateNodeNum);
        replicas -= candidateNodeNum;
        break;
      } else if ("R".equals(num)) {
        // wait until we get the counts for all other states
        continue;
      } else {
        int stateCount = -1;
        try {
          stateCount = Integer.parseInt(num);
        } catch (Exception e) {
        }

        if (stateCount > 0) {
          int count = stateCount <= candidateNodeNum ? stateCount : candidateNodeNum;
          candidateNodeNum -= count;
          stateCountMap.put(state, count);
          replicas -= count;
        }
      }
    }

    // get state count for R
    for (String state : statesPriorityList) {
      String num = getNumInstancesPerState(state);
      if ("R".equals(num)) {
        if (candidateNodeNum > 0 && replicas > 0) {
          stateCountMap.put(state, replicas < candidateNodeNum ? replicas : candidateNodeNum);
        }
        // should have at most one state using R
        break;
      }
    }
    return stateCountMap;
  }

  /**
   * 给定一个instance->state map, 返回它的state count
   *
   * @param stateMap
   *
   * @return state->count map for the given state map.
   */
  public static Map<String, Integer> getStateCounts(Map<String, String> stateMap) {
    Map<String, Integer> stateCounts = new HashMap<>();
    for (String state : stateMap.values()) {
      if (!stateCounts.containsKey(state)) {
        stateCounts.put(state, 0);
      }
      stateCounts.put(state, stateCounts.get(state) + 1);
    }
    return stateCounts;
  }
}

子类LeaderStandbySMD、MasterSlaveSMD、OnlineOfflineSMD、ScheduledTaskSMD、StorageSchemataSMD、TaskSMD
这些内建的模型定义在这个类被加载
public enum BuiltInStateModelDefinitions {
  MasterSlave(new MasterSlaveSMD()),
  LeaderStandby(new LeaderStandbySMD()),
  StorageSchemata(new StorageSchemataSMD()),
  OnlineOffline(new OnlineOfflineSMD()),
  ScheduledTask(new ScheduledTaskSMD()),
  Task(new TaskSMD());

  private final StateModelDefinition def;

  private BuiltInStateModelDefinitions(StateModelDefinition def) {
    this.def = def;
  }

  public StateModelDefinition getStateModelDefinition() {
    return def;
  }
}

而在ZKHelixManager中，内建状态模型定义和其他定义的添加方式，看起来是写入zk了,推测其他组件会读取这个定义

  /**
   * Add Helix built-in state model definitions if not exist
   */
  private void addBuiltInStateModelDefinitions() {
    for (BuiltInStateModelDefinitions def : BuiltInStateModelDefinitions.values()) {
      // creation succeeds only if not exist
      _dataAccessor.createStateModelDef(def.getStateModelDefinition());
    }
  }
  
  @Override
  public boolean createStateModelDef(StateModelDefinition stateModelDef) {
    String path = PropertyPathBuilder.stateModelDef(_clusterName, stateModelDef.getId());
    HelixProperty property =
        getProperty(new PropertyKey.Builder(_clusterName).stateModelDef(stateModelDef.getId()));

    // Set new StateModelDefinition if it is different from old one.
    if (property != null) {
      // StateModelDefinition need to be updated
      if (!new StateModelDefinition(property.getRecord()).equals(stateModelDef)) {
        return stateModelDef.isValid() && _baseDataAccessor
            .set(path, stateModelDef.getRecord(), AccessOption.PERSISTENT);
      }
    } else {
      // StateModeDefinition does not exist
      return stateModelDef.isValid() && _baseDataAccessor
          .create(path, stateModelDef.getRecord(), AccessOption.PERSISTENT);
    }
    // StateModelDefinition exists but not need to be updated
    return true;
  }
  
  
  @Override
  public void addStateModelDef(String clusterName, String stateModelDef,
      StateModelDefinition stateModel, boolean recreateIfExists) {
    logger
        .info("Add StateModelDef {} in cluster {} with StateModel {}.", stateModelDef, clusterName,
            stateModel == null ? "NULL" : stateModel.toString());
    if (!ZKUtil.isClusterSetup(clusterName, _zkClient)) {
      throw new HelixException("cluster " + clusterName + " is not setup yet");
    }
    String stateModelDefPath = PropertyPathBuilder.stateModelDef(clusterName);
    String stateModelPath = stateModelDefPath + "/" + stateModelDef;
    if (_zkClient.exists(stateModelPath)) {
      if (recreateIfExists) {
        logger.info(
            "Operation.State Model directory exists:" + stateModelPath + ", remove and recreate.");
        _zkClient.deleteRecursively(stateModelPath);
      } else {
        logger.info("Skip the operation. State Model directory exists:" + stateModelPath);
        return;
      }
    }
    
    HelixDataAccessor accessor =
        new ZKHelixDataAccessor(clusterName, new ZkBaseDataAccessor<ZNRecord>(_zkClient));
    Builder keyBuilder = accessor.keyBuilder();
    accessor.setProperty(keyBuilder.stateModelDef(stateModelDef), stateModel);
  }
```

```

/**
 * 描述状态模型定义，先看构造方法
 */
public class StateModelDefinition extends HelixProperty {
  public enum StateModelDefinitionProperty {
    INITIAL_STATE,
    STATE_TRANSITION_PRIORITYLIST,
    STATE_PRIORITY_LIST
  }

  /**
   * 初始状态
   */
  private final String _initialState;

  /**
   * 优先级顺序下的状态的名字，表明状态的顺序
   */
  private final List<String> _statesPriorityList;

  /**
   * 指定某状态下的实例（节点）的数量
   * -1 不关心，不用尝试保证任何在此state资源下的存在于任何节点
   * >0 大于0的整数代表着必须处于此节点的数量
   * R 所有在偏好配置中的节点必须处于此状态
   * N 所有节点必须都放进偏好列表state.PreferenceList，必须表示为*
   */
  private final Map<String, String> _statesCountMap;

  private final List<String> _stateTransitionPriorityList;

  private Map<String, Integer> _statesPriorityMap = new HashMap<>();

  /**
   * 状态转换，用于查找nextState 和 FinalState
   * 
   */
  private final Map<String, Map<String, String>> _stateTransitionTable;

  /**
   * 从预先填充的记录实例化
   * @param record ZNRecord representing a state model definition
   */
  public StateModelDefinition(ZNRecord record) {
    super(record);

    _initialState = record.getSimpleField(StateModelDefinitionProperty.INITIAL_STATE.toString());

    if (_initialState == null) {
      throw new IllegalArgumentException("initial-state for " + record.getId() + " is null");
    }

    _statesPriorityList =
        record.getListField(StateModelDefinitionProperty.STATE_PRIORITY_LIST.toString());
    _stateTransitionPriorityList =
        record.getListField(StateModelDefinitionProperty.STATE_TRANSITION_PRIORITYLIST.toString());
    _stateTransitionTable = new HashMap<>();
    _statesCountMap = new HashMap<>();
    if (_statesPriorityList != null) {
      int priority = 1;
      for (String state : _statesPriorityList) {
        Map<String, String> metaData = record.getMapField(state + ".meta");
        if (metaData != null) {
          if (metaData.get("count") != null) {
            _statesCountMap.put(state, metaData.get("count"));
          }
        }
        Map<String, String> nextData = record.getMapField(state + ".next");
        _stateTransitionTable.put(state, nextData);
        _statesPriorityMap.put(state, priority++);
      }
    }

    // 添加 HelixDefinedState 到 statesPriorityMap 防止还没有被添加过
    for (HelixDefinedState state : HelixDefinedState.values()) {
      if (!_statesPriorityMap.containsKey(state.name())) {
        // 使用最低的优先级
        _statesPriorityMap.put(state.name(), Integer.MAX_VALUE);
      }
    }

    // 为 helix-defined states 添加转换
    for (HelixDefinedState state : HelixDefinedState.values()) {
      if (_statesPriorityList == null || !_statesPriorityList.contains(state.toString())) {
        _statesCountMap.put(state.toString(), "-1");
      }
    }
    
    //添加默认的转换ERROR、DROPPED相关
    addDefaultTransition(HelixDefinedState.ERROR.toString(), HelixDefinedState.DROPPED.toString(),
        HelixDefinedState.DROPPED.toString());
    addDefaultTransition(HelixDefinedState.ERROR.toString(), _initialState, _initialState);
    addDefaultTransition(_initialState, HelixDefinedState.DROPPED.toString(),
        HelixDefinedState.DROPPED.toString());
  }

  /**
   * 添加于 helix-defines states相关的转换
   * these transitions need not to be specified in state-model-definition
   * @param from source state
   * @param to destination state
   * @param next intermediate state to reach the destination
   */
  void addDefaultTransition(String from, String to, String next) {
    if (!_stateTransitionTable.containsKey(from)) {
      _stateTransitionTable.put(from, new TreeMap<String, String>());
    }

    if (!_stateTransitionTable.get(from).containsKey(to)) {
      _stateTransitionTable.get(from).put(to, next);
    }
  }

  /**
   * 获取一个排序过的转换的list
   * @return transitions in the form SRC-DEST, the first of which is highest priority
   */
  public List<String> getStateTransitionPriorityList() {
    return _stateTransitionPriorityList;
  }

  public Map<String, Integer> getStatePriorityMap() {
    return _statesPriorityMap;
  }

  /**
   * 获取一个排序过的转换
   * @return state names, the first of which is highest priority
   */
  public List<String> getStatesPriorityList() {
    return _statesPriorityList;
  }

  /**
   * 得到从一个状态过渡到另一个状态所需的中间状态
   * @param fromState the source
   * @param toState the destination
   * @return the intermediate state
   */
  public String getNextStateForTransition(String fromState, String toState) {
    Map<String, String> map = _stateTransitionTable.get(fromState);
    if (map != null) {
      return map.get(toState);
    }
    return null;
  }

  /**
   * 获取初始状态
   * @return name of the initial state
   */
  public String getInitialState() {
    return _initialState;
  }

  /**
   * 获取每个状态的实例数
   * @param state the state name
   * @return maximum instance count per state, can be "N" or "R"
   */
  public String getNumInstancesPerState(String state) {
    return _statesCountMap.get(state);
  }

  /**
   * 获取状态模型的顶级状态
   * @return
   */
  public String getTopState() {
    return _statesPriorityList.get(0);
  }

  /**
   * 状态模型是否只允许最多一个副本在顶级状态？
   *
   * @return
   */
  public boolean isSingleTopStateModel() {
    int topStateCount = 0;
    try {
      topStateCount = Integer.valueOf(_statesCountMap.get(getTopState()));
    } catch (NumberFormatException ex) {

    }

    return topStateCount == 1;
  }

  /**
   * 获取二级状态，那种需要两次转换才能到顶级状态的
   * @return a set of second top states
   */
  public Set<String> getSecondTopStates() {
    Set<String> secondTopStates = new HashSet<String>();
    if (_statesPriorityList == null || _statesPriorityList.isEmpty()) {
      return secondTopStates;
    }
    String topState = _statesPriorityList.get(0);
    for (String state : _stateTransitionTable.keySet()) {
      Map<String, String> transitionMap = _stateTransitionTable.get(state);
      if (transitionMap != null && transitionMap.containsKey(topState) && transitionMap
          .get(topState).equals(topState)) {
        secondTopStates.add(state);
      }
    }
    return secondTopStates;
  }

  @Override
  public boolean isValid() {
    return StateModelDefinitionValidator.isStateModelDefinitionValid(this);
  }
```

```
//参与者 HelixManager是连接组件的工具
HelixManager manager = HelixManagerFactory.getZKHelixManager(clusterName, "localhost_12914", InstanceType.PARTICIPANT, zookeeper);
//获取到状态机,注册状态模型
StateMachineEngine stateMachineEngine = manager.getStateMachineEngine(); 
stateMachineEngine.registerStateModelFactory("OnlineOffline", new MyOnlineOfflineStateModelFactory("localhost_12914"));

public interface StateMachineEngine extends MultiTypeMessageHandlerFactory {
  /**
   * Register a default state model factory for a state model definition
   * A state model definition could be, for example:
   * "MasterSlave", "OnlineOffline", "LeaderStandby", etc.
   * @param stateModelDef
   * @param factory
   * @return
   */
  public boolean registerStateModelFactory(String stateModelDef,
      StateModelFactory<? extends StateModel> factory);
      

public abstract class StateModelFactory<T extends StateModel> {

  /**
   * This method will be invoked only once per resource per partition per session
   * Replace deprecating StateModelFactory#createNewStateModel(String partitionName)
   * Add "resourceName" to signature @see HELIX-552
   * @param resourceName
   * @param partitionName
   * @return state model
   */
  public T createNewStateModel(String resourceName, String partitionName) {
    // default implementation ignores resourceName
    return createNewStateModel(partitionName);
  }
  
  
  /**
   * Create a state model for a partition
   * @param partitionKey
   * @return state model
   */
  public T createAndAddStateModel(String resourceName, String partitionKey) {
    T stateModel = createNewStateModel(resourceName, partitionKey);
    synchronized (_stateModelMap) {
      if (!_stateModelMap.containsKey(resourceName)) {
        _stateModelMap.put(resourceName, new ConcurrentHashMap<String, T>());
      }
      _stateModelMap.get(resourceName).put(partitionKey, stateModel);
    }
    return stateModel;
  }
  
在HelixStateMachineEngine中createHandler会调用工厂的这个方法
if (!message.getBatchMessageMode()) {
      String initState = _stateModelDefs.get(message.getStateModelDef()).getInitialState();
      StateModel stateModel = stateModelFactory.getStateModel(resourceName, partitionKey);
      if (stateModel == null) {
        stateModel = stateModelFactory.createAndAddStateModel(resourceName, partitionKey);
```

```
接口的实现类有BootstrapHandler、DistClusterControllerStateModelFactory、GenericLeaderStandbyStateModelFactory、LeaderStandbyStateModelFactory、MasterSlaveStateModelFactory、OnlineOfflineStateModelFactory、ScheduledTaskStateModelFactory、TaskStateModelFactory等
  
以OnlineOfflineStateModelFactory为例
  @Override
  public StateModel createNewStateModel(String resourceName, String stateUnitKey) {
    OnlineOfflineStateModel stateModel = new OnlineOfflineStateModel();
    stateModel.setDelay(_delay);
    stateModel.setInstanceName(_instanceName);
    return stateModel;
  }
```

## StateModel和StateModelDefinition的关系？

```
StateModel应该代表了运行中的状态机中具体的状态实例
StateModelDefinition定义的是状态机
StateModel的实例应该在运行中被自动创建和管理，但我们要在参与者中指定它
在2.1.1 Participant 参与者中，创建Helix管理器实例后，唯一需要注册的是状态模型工厂（state model factory）。当控制器向参与者发送转换（transitions）时，将调用状态模型的方法
StateModelDefinition会有helix的内置的，也可以添加其他自定义的
实际上很多地方会用到StateModelDefinition的实例，如AbstractRebalancer中就用到了
并且源码中很多工具类其实也是调用helixmanager的addStateModelDef方法添加的自定义
```

```
public class IdealStateBuilderExample {

  private static String buildPartitionName(String resourceName, int partitionNum) {
    return resourceName + "_" + partitionNum;
  }

  public static void main(String[] args) {

    if (args.length < 3) {
      System.err
          .println("USAGE: java IdealStateBuilderExample zkAddress clusterName idealStateMode"
              + " (FULL_AUTO, SEMI_AUTO, CUSTOMIZED, or USER_DEFINED)");
      System.exit(1);
    }

    final String zkAddr = args[0];
    final String clusterName = args[1];
    RebalanceMode idealStateMode = RebalanceMode.valueOf(args[2].toUpperCase());

    HelixZkClient.ZkClientConfig clientConfig = new HelixZkClient.ZkClientConfig();
    clientConfig.setZkSerializer(new ZNRecordSerializer());
    final HelixZkClient zkClient = SharedZkClientFactory.getInstance()
        .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddr), clientConfig);
    ZKHelixAdmin admin = new ZKHelixAdmin(zkClient);

    // add cluster
    admin.addCluster(clusterName, true);

    // add MasterSlave state model definition
    admin.addStateModelDef(clusterName, "MasterSlave", new StateModelDefinition(
        StateModelConfigGenerator.generateConfigForMasterSlave()));

    // add 2 participants: "localhost:{12918, 12919}"
    int n = 2;
    for (int i = 0; i < n; i++) {
      int port = 12918 + i;
      InstanceConfig config = new InstanceConfig("localhost_" + port);
      config.setHostName("localhost");
      config.setPort(Integer.toString(port));
      config.setInstanceEnabled(true);
      admin.addInstance(clusterName, config);
    }

    // add ideal-state according to ideal-state-mode
    String resourceName = "TestDB";
    IdealState idealState = null;
    switch (idealStateMode) {
    case SEMI_AUTO: {
      SemiAutoModeISBuilder builder = new SemiAutoModeISBuilder(resourceName);
      builder.setStateModel("MasterSlave").setNumPartitions(2).setNumReplica(2);
      builder.assignPreferenceList(buildPartitionName(resourceName, 0), "localhost_12918",
          "localhost_12919").assignPreferenceList(buildPartitionName(resourceName, 1),
          "localhost_12919", "localhost_12918");

      idealState = builder.build();
      break;
    }
    case FULL_AUTO: {
      FullAutoModeISBuilder builder = new FullAutoModeISBuilder(resourceName);
      builder.setStateModel("MasterSlave").setNumPartitions(2).setNumReplica(2)
          .setMaxPartitionsPerNode(2);
      builder.add(buildPartitionName(resourceName, 0)).add(buildPartitionName(resourceName, 1));

      idealState = builder.build();
      break;
    }
    case CUSTOMIZED: {
      CustomModeISBuilder builder = new CustomModeISBuilder(resourceName);
      builder.setStateModel("MasterSlave").setNumPartitions(2).setNumReplica(2);
      builder
          .assignInstanceAndState(buildPartitionName(resourceName, 0), "localhost_12918", "MASTER")
          .assignInstanceAndState(buildPartitionName(resourceName, 0), "localhost_12919", "SLAVE")
          .assignInstanceAndState(buildPartitionName(resourceName, 1), "localhost_12918", "SLAVE")
          .assignInstanceAndState(buildPartitionName(resourceName, 1), "localhost_12919", "MASTER");
      idealState = builder.build();
      break;
    }
    default:
      break;
    }

    admin.addResource(clusterName, resourceName, idealState);

    // start helix controller
    new Thread(new Runnable() {
      @Override
      public void run() {
        try {
          HelixControllerMain.main(new String[] {
              "--zkSvr", zkAddr, "--cluster", clusterName
          });
        } catch (Exception e) {
          // TODO Auto-generated catch block
          e.printStackTrace();
        }
      }
    }).start();

    // start dummy participants
    for (int i = 0; i < n; i++) {
      int port = 12918 + i;
      final String instanceName = "localhost_" + port;
      new Thread(new Runnable() {
        @Override
        public void run() {
          DummyParticipant.main(new String[] {
              zkAddr, clusterName, instanceName
          });
        }
      }).start();
    }
  }
}

```

