创建集群

```
# ./helix-admin.sh --zkSvr <zk_address> --addCluster <clustername>
./helix-admin.sh --zkSvr <zk_address> --addCluster cluster-demo
```

添加节点到集群

```
# helix-admin.sh --zkSvr <zk_address>  --addNode <clustername> <host:port>
./helix-admin.sh --zkSvr <zk_address> --addNode cluster-demo localhost:12913
./helix-admin.sh --zkSvr <zk_address> --addNode cluster-demo localhost:12914
./helix-admin.sh --zkSvr <zk_address> --addNode cluster-demo localhost:12915
```

定义资源和分区

```
# helix-admin.sh --zkSvr <zk_address> --addResource <clustername> <resourceName> <numPartitions> <StateModelName>
./helix-admin.sh --zkSvr <zk_address> --addResource cluster-demo resource-demo 6 OnlineOffline SEMI_AUTO
```

到这里先看看这个资源的详情

```
# helix-admin.sh --zkSvr <zk_address> --listResourceInfo <clusterName> <resourceName>
./helix-admin.sh --zkSvr localhost:2199 --listResourceInfo cluster-demo resource-demo

{
  "id" : "resource-demo",
  "mapFields" : {
  },
  "listFields" : {
  },
  "simpleFields" : {
    "IDEAL_STATE_MODE" : "AUTO",
    "NUM_PARTITIONS" : "3",
    "REBALANCE_MODE" : "SEMI_AUTO",
    "REBALANCE_STRATEGY" : "DEFAULT",
    "REPLICAS" : "0",
    "STATE_MODEL_DEF_REF" : "OnlineOffline",
    "STATE_MODEL_FACTORY_NAME" : "DEFAULT"
  }
}
```

执行一下rebalance看看效果

```
# helix-admin.sh --zkSvr <zk_address> --rebalance <clustername> <resourceName> <replication factor> 副本数参数
./helix-admin.sh --zkSvr localhost:2199 --rebalance cluster-demo resource-demo 1

{
  "id" : "resource-demo",
  "mapFields" : {
    "resource-demo_0" : {
      "localhost_12913" : "ONLINE"
    },
    "resource-demo_1" : {
      "localhost_12915" : "ONLINE"
    },
    "resource-demo_2" : {
      "localhost_12914" : "ONLINE"
    }
  },
  "listFields" : {
    "resource-demo_0" : [ "localhost_12913" ],
    "resource-demo_1" : [ "localhost_12915" ],
    "resource-demo_2" : [ "localhost_12914" ]
  },
  "simpleFields" : {
    "IDEAL_STATE_MODE" : "AUTO",
    "NUM_PARTITIONS" : "3",
    "REBALANCE_MODE" : "SEMI_AUTO",
    "REBALANCE_STRATEGY" : "DEFAULT",
    "REPLICAS" : "1",
    "STATE_MODEL_DEF_REF" : "OnlineOffline",
    "STATE_MODEL_FACTORY_NAME" : "DEFAULT"
  }
}
```

启动控制器

```
./run-helix-controller.sh --zkSvr localhost:2199 --cluster cluster-demo 2>&1 > /tmp/controller.log &
```

启动参与者程序（下面代码只有在资源时MasterSlave是正常的，这里我自己写了程序然后启动的）

```
./start-helix-participant.sh --zkSvr localhost:2199 --cluster cluster-demo --host localhost --port 12913 --stateModelType MasterSlave 2>&1 > /tmp/participant_12913.log
./start-helix-participant.sh --zkSvr localhost:2199 --cluster cluster-demo --host localhost --port 12914 --stateModelType MasterSlave 2>&1 > /tmp/participant_12914.log
./start-helix-participant.sh --zkSvr localhost:2199 --cluster cluster-demo --host localhost --port 12915 --stateModelType MasterSlave 2>&1 > /tmp/participant_12915.log
```

查看资源状态,会发现ExternalView for resource-demo有变化

```
./helix-admin.sh --zkSvr localhost:2199 --listResourceInfo cluster-demo resource-demo
```

下面试一下能否手动配置listFields

```
./helix-admin.sh --zkSvr localhost:2199 --addIdealState <clusterName resourceName <filename>>
./helix-admin.sh --zkSvr localhost:2199 --addIdealState cluster-demo resource-demo test.json

{
  "id" : "resource-demo",
  "mapFields" : {
    "resource-demo_0" : {
      "localhost_12913" : "ONLINE"
    },
    "resource-demo_1" : {
      "localhost_12915" : "ONLINE"
    },
    "resource-demo_2" : {
      "localhost_12914" : "ONLINE"
    }
  },
  "listFields" : {
    "resource-demo_0" : [ "localhost_12913" ],
    "resource-demo_1" : [ "localhost_12914" ],
    "resource-demo_2" : [ "localhost_12914" ]
  },
  "simpleFields" : {
    "IDEAL_STATE_MODE" : "AUTO",
    "NUM_PARTITIONS" : "3",
    "REBALANCE_MODE" : "SEMI_AUTO",
    "REBALANCE_STRATEGY" : "DEFAULT",
    "REPLICAS" : "1",
    "STATE_MODEL_DEF_REF" : "OnlineOffline",
    "STATE_MODEL_FACTORY_NAME" : "DEFAULT"
  }
}
```

发现代码运行分配到了新的分区，然后再次查看资源状态

```
IdealState for resource-demo:
{
  "id" : "resource-demo",
  "mapFields" : {
    "resource-demo_0" : {
      "localhost_12913" : "ONLINE"
    },
    "resource-demo_1" : {
      "localhost_12915" : "ONLINE" //这里是不对的？
    },
    "resource-demo_2" : {
      "localhost_12914" : "ONLINE"
    }
  },
  "listFields" : {
    "resource-demo_0" : [ "localhost_12913" ],
    "resource-demo_1" : [ "localhost_12914" ], //但是这里改了
    "resource-demo_2" : [ "localhost_12914" ]
  },
  "simpleFields" : {
    "IDEAL_STATE_MODE" : "AUTO",
    "NUM_PARTITIONS" : "3",
    "REBALANCE_MODE" : "SEMI_AUTO",
    "REBALANCE_STRATEGY" : "DEFAULT",
    "REPLICAS" : "1",
    "STATE_MODEL_DEF_REF" : "OnlineOffline",
    "STATE_MODEL_FACTORY_NAME" : "DEFAULT"
  }
}

ExternalView for resource-demo:
{
  "id" : "resource-demo",
  "mapFields" : {
    "resource-demo_1" : {
      "localhost_12914" : "ONLINE" //这里也改了
    },
    "resource-demo_2" : {
      "localhost_12914" : "ONLINE"
    }
  },
  "listFields" : {
  },
  "simpleFields" : {
    "BUCKET_SIZE" : "0",
    "IDEAL_STATE_MODE" : "AUTO",
    "NUM_PARTITIONS" : "3",
    "REBALANCE_MODE" : "SEMI_AUTO",
    "REBALANCE_STRATEGY" : "DEFAULT",
    "REPLICAS" : "1",
    "STATE_MODEL_DEF_REF" : "OnlineOffline",
    "STATE_MODEL_FACTORY_NAME" : "DEFAULT"
  }
}
```

再次执行一次Rebalance,然后重新查看状态

```
./helix-admin.sh --zkSvr localhost:2199 --rebalance cluster-demo resource-demo 1
```

发现rebalance每次都会重新确定分区的位置，是一个随机的行为

尝试对test.json做些修改

1.只改变状态mapping看看是否会影响状态变化 (SEMI_AUTO下)，没有任何影响，应该是没有用到这块数据

2.去掉状态mapping看看，仍然可以运行，重启后也能正常恢复



代办：验证MasterSlave在节点恢复的时候会不会自动再回来



```
//代码设定IS并添加资源
SemiAutoModeISBuilder builder = new SemiAutoModeISBuilder(resourceName);
builder.setStateModel("MasterSlave").setNumPartitions(2).setNumReplica(2);

builder.
assignPreferenceList(buildPartitionName(resourceName, 0), "localhost_12918","localhost_12919")
.assignPreferenceList(buildPartitionName(resourceName, 1),"localhost_12919", "localhost_12918");

idealState = builder.build();
admin.addResource(clusterName, resourceName, idealState);
```



```
1. 定义（参与者）
1.1定义状态模型 - 使用状态模型定义的Builder
状态 - addState
转换 - addTransition
1.2定义状态约束 - 某状态副本的个数，并发执行的转换数等 upperBound、dynamicUpperBound
1.3编写配置转换时的逻辑 - @StateModelInfo @Transition

2.配置
创建集群 - addCluster
添加节点 - addNode (节点可以在启动时自动加入集群)
添加资源 - addResource（考虑代码添加资源）
配置重平衡器 - rebalance(重平衡策略尽量在节点变化的时候重平衡影响最小)

3.运行
开启控制器
开启参与者
```



```

```

