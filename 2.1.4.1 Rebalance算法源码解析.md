- FULL_AUTO
- SEMI_AUTO
- CUSTOMIZED
- USER_DEFINED



Rebalancer接口

```
/**
 * Helix允许用户自己实现rebalancer
 * 所有集群上的改变都会调用rebalancer
 * 只需要为resource返回newIdealState就可以了
 */
public interface Rebalancer<T extends BaseControllerDataProvider> {
  void init(HelixManager manager);

  /**
   * 这个方法为resource的重平衡提供所有相关信息
   * 如果需要额外的信息，可以通过manager.getAccessor 来读取集群数据.
   * 这里允许用户来计算newIdealState，来支持特殊APP的需求
   * @param resourceName 要进行rb的resource
   * @param currentIdealState 当前理想状态
   * @param currentStateOutput 提供每个分区的当前状态以及正在进行中的状态转换         
   * @param clusterData 提供额外的方法来获取集群数据
   * @return
   */
   IdealState computeNewIdealState(String resourceName,
      IdealState currentIdealState, final CurrentStateOutput currentStateOutput,
      T clusterData);
}
```

MappingCalculator接口

```
/**
 * 通过将IdealState转换为ResourceAssignment，扩展Rebalancer的功能 
 * WARNING: 这是一个内部接口，可能随着版本发布而改变
 */
public interface MappingCalculator<T extends BaseControllerDataProvider> {
  /**
   * 给定resource的理想状态和当前存活的实例节点，为每个分区的副本计算最佳的可能的状态分配
   * @param cache
   * @param idealState
   * @param resource
   * @param currentStateOutput 提供每个分区的当前状态以及正在进行中的状态转换    
   * @return
   */
  ResourceAssignment computeBestPossiblePartitionState(
      T cache, IdealState idealState, Resource resource, CurrentStateOutput currentStateOutput);
}
```

RebalanceStrategy接口

```
public interface RebalanceStrategy<T extends BaseControllerDataProvider> {
  String DEFAULT_REBALANCE_STRATEGY = "DEFAULT"; //默认为DEFAULT

  /**
   * 为重平衡策略执行必要的初始化
   *
   * @param resourceName
   * @param partitions
   * @param states
   * @param maximumPerNode
   */
  void init(String resourceName, final List<String> partitions,
      final LinkedHashMap<String, Integer> states, int maximumPerNode);

  /**
   * 为给定的resource计算偏好list（preference lists）以及可选的分区状态映射
   *
   * @param liveNodes
   * @param currentMapping
   * @param allNodes
   * @return
   */
  ZNRecord computePartitionAssignment(final List<String> allNodes, final List<String> liveNodes,
      final Map<String, Map<String, String>> currentMapping,
      T clusterData);
}
```

AbstractRebalancer抽象类

```
/**
 * 这是一个抽象的rebalancer，为Helix rebalancer定义了许多默认的行为，同时给出了一些公用的工具性方法
 */
public abstract class AbstractRebalancer<T extends BaseControllerDataProvider> implements Rebalancer<T>,
    MappingCalculator<T> {
  // 这些应该是final的，但是在init方法中被初始化，而不是在构造函数
  protected HelixManager _manager;
  protected RebalanceStrategy<T> _rebalanceStrategy;

  private static final Logger LOG = LoggerFactory.getLogger(AbstractRebalancer.class);

  @Override
  public void init(HelixManager manager) {
    this._manager = manager;
    this._rebalanceStrategy = null;
  }

//这里是Rebalancer接口的核心方法，并没有实现
  @Override
  public abstract IdealState computeNewIdealState(
      String resourceName, IdealState currentIdealState, CurrentStateOutput currentStateOutput,
      T clusterData);

  /**
   * 为所有分区计算最佳状态，这里是MappingCalculator接口
   * 这是一个默认实现，如果子类的需求不同，子类应重新实现
   *
   * @param cache
   * @param idealState
   * @param resource
   * @param currentStateOutput 提供每个分区的当前状态以及正在进行中的状态转换
   * @return 返回了ResourceAssignment
   */
  @Override
  public ResourceAssignment computeBestPossiblePartitionState(
      T cache, IdealState idealState, Resource resource,
      CurrentStateOutput currentStateOutput) {
    if (LOG.isDebugEnabled()) {
      LOG.debug("Processing resource:" + resource.getResourceName());
    }
    //状态模型名称
    String stateModelDefName = idealState.getStateModelDefRef();
    //从cache中获取状态模型定义
    StateModelDefinition stateModelDef = cache.getStateModelDef(stateModelDefName);
    //新建一个resource的分区分配
    ResourceAssignment partitionMapping = new ResourceAssignment(resource.getResourceName());
    //遍历所有分区
    for (Partition partition : resource.getPartitions()) {
    //获取分区被禁用的节点列表
      Set<String> disabledInstancesForPartition =
          cache.getDisabledInstancesForPartition(resource.getResourceName(), partition.toString());
          //获取偏好的列表，内部调用 1，传入了集群存活的节点
      List<String> preferenceList = getPreferenceList(partition, idealState,
          Collections.unmodifiableSet(cache.getLiveInstances().keySet()));
          //分区最佳状态计算，内部调用 2，
      Map<String, String> bestStateForPartition =
          computeBestPossibleStateForPartition(cache.getLiveInstances().keySet(), stateModelDef,
              preferenceList, currentStateOutput, disabledInstancesForPartition, idealState,
              cache.getClusterConfig(), partition);
      partitionMapping.addReplicaMap(partition, bestStateForPartition);
    }
    return partitionMapping;
  }
  
  //内部调用1，返回的是偏好节点列表，
  public static List<String> getPreferenceList(Partition partition, IdealState idealState,
      Set<String> eligibleInstances) {
      //获取分区的理想状态配置
    List<String> listField = idealState.getPreferenceList(partition.getPartitionName());

//配置不为空，size是1，并且配置是ANY_LIVEINSTANCE的话，对合格的节点排序后返回，否则，返回配置
    if (listField != null && listField.size() == 1
        && IdealState.IdealStateConstants.ANY_LIVEINSTANCE.toString().equals(listField.get(0))) {
      List<String> prefList = new ArrayList<String>(eligibleInstances);
      Collections.sort(prefList);
      return prefList;
    } else {
      return listField;
    }
  }
  
  //内部调用2，为分区计算最佳状态
  //参数：存活节点，状态模型定义，偏好列表，当前状态，分区被禁用的节点，理想状态，集群配置，分区
  protected Map<String, String> computeBestPossibleStateForPartition(Set<String> liveInstances,
      StateModelDefinition stateModelDef, List<String> preferenceList,
      CurrentStateOutput currentStateOutput, Set<String> disabledInstancesForPartition,
      IdealState idealState, ClusterConfig clusterConfig, Partition partition) {

//通过当前的currentStateOutput获取到当前的状态map
    Map<String, String> currentStateMap =
        currentStateOutput.getCurrentStateMap(idealState.getResourceName(), partition);

    if (currentStateMap == null) {
      currentStateMap = Collections.emptyMap();
    }

    // (1) 如果分区从理想状态IS移除或者IS被删除，不管节点是否是禁用的，转移到DROPPED状态
    //内部调用 3
    if (preferenceList == null) {
      return computeBestPossibleMapForDroppedResource(currentStateMap);
    }

    // (2) 如果资源被禁用了，如果它不在ERROR状态，转换为初始状态如OFFLINE
    //内部调用4
    if (!idealState.isEnabled()) {
      return computeBestPossibleMapForDisabledResource(currentStateMap, stateModelDef);
    }

    //否则进行计算，内部调用5
    return computeBestPossibleMap(preferenceList, stateModelDef, currentStateMap, liveInstances,
        disabledInstancesForPartition);
  }
  
  //内部调用3，将当前状态map中设置为DROPPED
  protected Map<String, String> computeBestPossibleMapForDroppedResource(Map<String, String> currentStateMap) {
    Map<String, String> bestPossibleStateMap = new HashMap<String, String>();
    for (String instance : currentStateMap.keySet()) {
      bestPossibleStateMap.put(instance, HelixDefinedState.DROPPED.toString());
    }
    return bestPossibleStateMap;
  }
  
  //内部调用4
  protected Map<String, String> computeBestPossibleMapForDisabledResource(Map<String, String> currentStateMap
      , StateModelDefinition stateModelDef) {
    Map<String, String> bestPossibleStateMap = new HashMap<String, String>();
    for (String instance : currentStateMap.keySet()) {
      if (!HelixDefinedState.ERROR.name().equals(currentStateMap.get(instance))) {
        bestPossibleStateMap.put(instance, stateModelDef.getInitialState());
      }
    }
    return bestPossibleStateMap;
  }
  
  //内部调用 5
  /**
   * 这个方法为分区生成instance->state映射。基于他的偏好preferenceList和状态模型定义
   * preferenceList在不同的rebalancer可能会不同，比如DelayedAutoRebalancer
   * 这个方法也确保一些边界情况，像是disabled的节点或者ERROR的节点能被正确处理
   * currentStateMap必须是非空的
   */
  protected Map<String, String> computeBestPossibleMap(List<String> preferenceList, StateModelDefinition stateModelDef,
      Map<String, String> currentStateMap, Set<String> liveInstances, Set<String> disabledInstancesForPartition) {

    Map<String, String> bestPossibleStateMap = new HashMap<>();

    // (1) 节点有当前状态，但是不在偏好列表中，不管他是否被禁用，都丢弃
    for (String instance : currentStateMap.keySet()) {
      if (!preferenceList.contains(instance)) {
        bestPossibleStateMap.put(instance, HelixDefinedState.DROPPED.name());
      }
    }

    // (2) 如果节点被禁用，并且在偏好列表中，设置为初始状态；当心条件判断
    for (String instance : preferenceList) {
      if (disabledInstancesForPartition.contains(instance)) {
        if (currentStateMap.containsKey(instance)) {
        //偏好节点在当前状态里，并且不是ERROR状态，变为初始状态
          if (!currentStateMap.get(instance).equals(HelixDefinedState.ERROR.name())) {
            bestPossibleStateMap.put(instance, stateModelDef.getInitialState());
          }
        } else {
        //如果偏好中的不在当前状态，也要添加，并设置为初始状态
          if (liveInstances.contains(instance)) {
            bestPossibleStateMap.put(instance, stateModelDef.getInitialState());
          }
        }
      }
    }

    // (3) 为节点分配正常的状态
    // 当选择类似于MASTER的高级状态时，优先从已经在二级状态如SLAVE中选择；而不是更低级的状态
    // 因为二级状态的将使用更少的时间来转换为高级状态，这样可能会对app的可用性造成最小的影响
    // 为了实现，基于CurrentState对preferenceList进行排序；把高级状态和二级状态视为同一优先级；
    // 并且依赖Collections.sort() 排序是稳定的.
    List<String> statesPriorityList = stateModelDef.getStatesPriorityList();
    Set<String> assigned = new HashSet<>();
    Set<String> liveAndEnabled = new HashSet<>(liveInstances);
    //存活的并且可用的节点
    liveAndEnabled.removeAll(disabledInstancesForPartition);

    for (String state : statesPriorityList) {
      // 使用特定的排序的preferenceList 来选择顶级状态的节点
      if (state.equals(statesPriorityList.get(0))) {
        List<String> preferenceListForTopState = new ArrayList<>(preferenceList);
        
        //用的是这个比较器 TopStatePreferenceListComparator
        
        Collections.sort(preferenceListForTopState,
            new TopStatePreferenceListComparator(currentStateMap, stateModelDef));
        preferenceList = preferenceListForTopState;
      }

      //处于某种状态的副本数量，内部调用6
      int stateCount =
          getStateCount(state, stateModelDef, liveAndEnabled.size(), preferenceList.size());
      //遍历偏好列表
      for (String instance : preferenceList) {
        if (stateCount <= 0) {
          break;
        }
        //分配结果里不含该节点，并且节点还存活和可用的话
        if (!assigned.contains(instance) && liveAndEnabled.contains(instance)) {
        //当前是ERROR状态的节点，依然是ERROR
          if (HelixDefinedState.ERROR.toString().equals(currentStateMap.get(instance))) {
            bestPossibleStateMap.put(instance, HelixDefinedState.ERROR.toString());
          } else {
          //否则设置为正确的状态
            bestPossibleStateMap.put(instance, state);
            stateCount--;
          }
          //将节点加入已分配节点，下次循环不再使用
          assigned.add(instance);
        }
      }
    }

    return bestPossibleStateMap;
  }
  
  //内部调用6
  public static int getStateCount(String state, StateModelDefinition stateModelDef, int liveAndEnabledSize,
      int preferenceListSize) {
    String num = stateModelDef.getNumInstancesPerState(state);
    int stateCount = -1;
    if ("N".equals(num)) {
      stateCount = liveAndEnabledSize;
    } else if ("R".equals(num)) {
      stateCount = preferenceListSize;
    } else {
      try {
        stateCount = Integer.parseInt(num);
      } catch (Exception e) {
        LOG.error("Invalid count for state:" + state + " ,count=" + num);
      }
    }

    return stateCount;
  }
  
  //然后其他的方法都是额外的工具类方法了
  /**
   * 查找resource的缓存过的理想mapping，如果存在，不再进行再次计算
   * 缓存清理时机：在ResourceControllerDataProvider中，如果集群状态有任何变化都会导致潜在的理想状态变化
   * 这会避免AutoRebalanceStrategy中的flip-flop问题，同时也能改善性能，因为不需要每次都计算IS
   */
  protected IdealState getCachedIdealState(String resourceName, ResourceControllerDataProvider clusterData) {
    ZNRecord cachedIdealMapping = clusterData.getCachedIdealMapping(resourceName);
    if (cachedIdealMapping != null) {
      return new IdealState(cachedIdealMapping);
    }

    return null;
  }

//当前的mapping
  protected Map<String, Map<String, String>> currentMapping(CurrentStateOutput currentStateOutput,
      String resourceName, List<String> partitions, Map<String, Integer> stateCountMap) {

    Map<String, Map<String, String>> map = new HashMap<>();

    for (String partition : partitions) {
      Map<String, String> curStateMap =
          currentStateOutput.getCurrentStateMap(resourceName, new Partition(partition));
      map.put(partition, new HashMap<String, String>());
      for (String node : curStateMap.keySet()) {
        String state = curStateMap.get(node);
        map.get(partition).put(node, state);
      }

      Map<String, String> pendingStateMap =
          currentStateOutput.getPendingStateMap(resourceName, new Partition(partition));
      for (String node : pendingStateMap.keySet()) {
        String state = pendingStateMap.get(node);
        map.get(partition).put(node, state);
      }
    }
    return map;
  }

//获取RB策略
  protected RebalanceStrategy<T> getRebalanceStrategy(
      String rebalanceStrategyName, List<String> partitions, String resourceName,
      LinkedHashMap<String, Integer> stateCountMap, int maxPartition) {
    RebalanceStrategy rebalanceStrategy;
    if (rebalanceStrategyName == null || rebalanceStrategyName
        .equalsIgnoreCase(RebalanceStrategy.DEFAULT_REBALANCE_STRATEGY)) {
      rebalanceStrategy =
          new AutoRebalanceStrategy(resourceName, partitions, stateCountMap, maxPartition);
    } else {
      try {
        rebalanceStrategy = RebalanceStrategy.class
            .cast(HelixUtil.loadClass(getClass(), rebalanceStrategyName).newInstance());
        rebalanceStrategy.init(resourceName, partitions, stateCountMap, maxPartition);
      } catch (ClassNotFoundException ex) {
        throw new HelixException(
            "Exception while invoking custom rebalance strategy class: " + rebalanceStrategyName,
            ex);
      } catch (InstantiationException ex) {
        throw new HelixException(
            "Exception while invoking custom rebalance strategy class: " + rebalanceStrategyName,
            ex);
      } catch (IllegalAccessException ex) {
        throw new HelixException(
            "Exception while invoking custom rebalance strategy class: " + rebalanceStrategyName,
            ex);
      }
    }

    return rebalanceStrategy;
  }

 
}
```

PreferenceListNodeComparator

```
/**
 * Sorter for nodes that sorts according to the CurrentState of the partition, based on the state priority defined
 * in the state model definition.
 * If the CurrentState doesn't exist, treat it as having lowest priority(Integer.MAX_VALUE).
 */
protected static class PreferenceListNodeComparator implements Comparator<String> {
  protected final Map<String, String> _currentStateMap;
  protected final StateModelDefinition _stateModelDef;
  protected final List<String> _preferenceList;

  public PreferenceListNodeComparator(Map<String, String> currentStateMap,
      StateModelDefinition stateModelDef, List<String> preferenceList) {
    _currentStateMap = currentStateMap;
    _stateModelDef = stateModelDef;
    _preferenceList = preferenceList;
  }

  @Override
  public int compare(String ins1, String ins2) {
    // condition :
    // 1. both in preference list, keep the order in preference list
    // 2. one them in preference list, the one in preference list has higher priority
    // 3. none of them in preference list, sort by state.
    if (_preferenceList.contains(ins1) && _preferenceList.contains(ins2)) {
      return _preferenceList.indexOf(ins1) - _preferenceList.indexOf(ins2);
    } else if (_preferenceList.contains(ins1)) {
      return -1;
    } else if (_preferenceList.contains(ins2)) {
      return 1;
    }
    Integer p1 = Integer.MAX_VALUE;
    Integer p2 = Integer.MAX_VALUE;

    Map<String, Integer> statesPriorityMap = _stateModelDef.getStatePriorityMap();
    String state1 = _currentStateMap.get(ins1);
    String state2 = _currentStateMap.get(ins2);
    if (state1 != null && statesPriorityMap.containsKey(state1)) {
      p1 = statesPriorityMap.get(state1);
    }
    if (state2 != null && statesPriorityMap.containsKey(state2)) {
      p2 = statesPriorityMap.get(state2);
    }

    return p1.compareTo(p2);
  }
}
```

FULL_AUTO

